`NLP задача Исправление ошибок, Rucode 6.0`

*Сделали: `Минина Полина` и `Нагимов Тимур`*

***Версия python:*** 3.9.11

***Ссылка на colab решения:*** https://colab.research.google.com/drive/1ye3yA0MOVHUc7roRSUjauVYQyBeZR49x?usp=sharing

## Описание задачи
В современном мире человечество производит огромный объем текстовой информации. 
Неудивительно, что в таком потоке данных нередко возникают ошибки (будь то названия товаров в магазинах или набранное сообщение на телефоне). 
Как ни странно, готовые решения не всегда дают лучший результат. 
Предлагаем вам поучаствовать в решении этой непростой задачи и обучить собственную модель для исправления ошибок в тексте.

## Инструкция по запуску решения
Для полного запуска решения от начала и до конца необходимы файлы **train.csv** и **private_test.csv**. Данные файлы есть в папке ***Файлы*** colab ноутбука, файл **train.csv** можно скачать здесь: https://drive.google.com/drive/folders/15AmDWf6EMhkI5WspKVKQplQYynFLku_k

При желании их можно изменить в следующих строчках:
```
train = pd.read_csv('train.csv')
```
```
test = pd.read_csv('private_test.csv')
```

По завершении выполнения кода будет создан файл ***1res_private.csv***, который и является результатом исправления текстов из файла ***private_test.csv***

## Описание решения
Бэйзлайн - прямолинейный подход: берём слово из corrupted_text и сопоставляем слову на той же позиции из corrected_text и записываем в словарь (ключ - неправильное слово, значение - список попавшихся исправлений).

Если слово не содержится в словаре неправильных слов, описанном выше, использовали подход ***Норвига*** (https://www.norvig.com/spell-correct.html), где составляются возможные исправления слова сначала на edit_distance == 1, потом 2 (здесь edit это delete, transpose, insert или replace). Здесь мы также получаем список возможных кандидатов. 

Для выбора из этого списка используем вероятностный подход и ***н-граммную модель*** (мы использовали только униграммы и биграммы). Выбираем либо наиболее вероятную биграмму, или, если её невозможно составить, просто наиболее вероятное слово.

После этого шага все равно остались сложные невалидные слова, поэтому мы решили использовать ***FastText***, который составляет эмбеддинги по сочетанию символов и искать ближайшие к нашему слову валидные слова и заменять на них
